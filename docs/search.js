window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "broom", "modulename": "broom", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "broom.clusters", "modulename": "broom.clusters", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "broom.clusters.get_and_save_real_tracers_B", "modulename": "broom.clusters", "qualname": "get_and_save_real_tracers_B", "kind": "function", "doc": "<p>Generate and save realistic tracer for MC-ILC given the instrumental and parameters configuration.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>config</strong> (Configs):\nConfiguration object containing the instrumental and parameters configuration. \nIt should contain the following attributes:\n<ul>\n<li>experiment : str\nName of the experiment</li>\n<li>lmax : int \nMaximum multipole for the simulations and analysis.      </li>\n<li>lmin : int\nMinimum multipole for the simulations and analysis.</li>\n<li>nside : int\nHEALPix resolution parameter.   </li>\n<li>data_type : str\nType of data to be used in the simulations, either \"maps\" or \"alms\". \nIt also identifies the type of data associated eventually to provided foregrounds and systematics.</li>\n<li>fwhm_out : float\nFull width at half maximum of the output beam in arcminutes used to generate the tracer.</li>\n<li>foreground_models : list\nList of foreground models to be used in the simulations. Used if foregrounds is None.</li>\n<li>real_mc_tracers : dict\nList of dictionaries containing the information about the MC-ILC tracers to be generated.\nIt should contain the following keys:\n<ul>\n<li>channels_tracers: list\nList of channels indexes to be used for the tracers generation. </li>\n<li>path_tracers : str\nPath where the tracers will be saved.</li>\n</ul></li>\n<li>bandpass_integrate : bool\nBoolean indicating whether to integrate over the bandpass of the instrument in the simulations.</li>\n<li>instrument : dict\nInstrument configuration object containing the following attributes:\n<ul>\n<li>channels_tags: list\nList of tags for the instrument channels.</li>\n</ul></li>\n<li>mask_observations : str\nPath to the mask which sets to zero unobserved pixels. If None, no mask is applied.</li>\n<li>coordinates : str\nCoordinate system used for the simulations, either \"G\" for Galactic, \"E\" for Ecliptic, or \"C\" for Celestial.</li>\n<li>pixel_window_in : bool\nBoolean indicating whether to apply the pixel window function to the input data.</li>\n<li>pixel_window_out : str \nBoolean indicating whether to apply the pixel window function to the output tracer.</li>\n<li>verbose : bool\nBoolean indicating whether to print information about the process.</li>\n</ul></li>\n<li><strong>foregrounds</strong> (np.ndarray, optional):\nForegrounds data to be used in the simulations for tracer generation. If None, the foregrounds will be generated using the configuration parameters.\nShape depends on <code>config.data_type</code>:\n<ul>\n<li>If \"maps\": (n_channels, 3, n_pixels) for (T, Q, U)</li>\n<li>If \"alms\": (n_channels, 3, n_alms) for (T, E, B)</li>\n</ul></li>\n<li><strong>systematics</strong> (np.ndarray, optional):\nSystematics data to be added to the simulations for tracer generation. If None, no systematics are added.\nIf provided, it should be a 3D array with shape:</li>\n<li><strong>(n_Shape depends on <code>config.data_type</code>:</strong>: - If \"maps\": (n_channels, 3, n_pixels) for (T, Q, U)\n<ul>\n<li>If \"alms\": (n_channels, 3, n_alms) for (T, E, B)</li>\n</ul></li>\n<li><strong>kwargs</strong> (dict, optional):\nAdditional keyword arguments to be passed to healpy 'map2alm' function.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong>: Saves the generated tracers to the configured output path.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">config</span><span class=\"p\">:</span> <span class=\"n\">broom</span><span class=\"o\">.</span><span class=\"n\">configurations</span><span class=\"o\">.</span><span class=\"n\">Configs</span>,</span><span class=\"param\">\t<span class=\"n\">foregrounds</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">systematics</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.clusters.initialize_scalar_tracers", "modulename": "broom.clusters", "qualname": "initialize_scalar_tracers", "kind": "function", "doc": "<p>Return the scalar tracers for the MC-ILC component separation run.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>config</strong> (Configs):\nConfiguration object containing the instrumental and parameters configuration. It should contain the following attributes:\n<ul>\n<li><code>nside</code>: HEALPix resolution parameter.</li>\n<li><code>lmax</code>: Maximum multipole for the tracers.</li>\n</ul></li>\n<li><strong>input_alms</strong> (np.ndarray):\nInput foreground alms from which the tracers will be derived if <code>compsep_run[\"mc_type\"]</code> is \"cea_ideal\" or \"rp_ideal\".\nIt should have shape (n_channels, n_alms).</li>\n<li><strong>compsep_run</strong> (dict):\nDictionary containing the information about the component separation run. It should contain the following keys:\n<ul>\n<li><code>mc_type</code>: Type of MC-ILC tracer and partition, either \"cea_ideal\", \"rp_ideal\", \"cea_real\", or \"rp_real\".</li>\n<li><code>domain</code>: Domain where component separation is performed, either \"needlet\" or \"pixel\".</li>\n<li><code>channels_tracers</code>: List of channels indexes to be used for the tracers generation or loading.</li>\n<li><code>path_tracers</code>: Path where the tracers will be loaded from if <code>compsep_run[\"mc_type\"]</code> is \"cea_real\" or \"rp_real\".</li>\n</ul></li>\n<li><strong>field</strong> (str, optional):\nField of the tracers to be loaded or derived, only \"B\" is supported. Default is \"B\".</li>\n<li><strong>kwargs</strong> (dict, optional):\nAdditional keyword arguments to be passed to healpy 'map2alm' function.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>tracers</strong> (np.ndarray):\nThe scalar tracers for the MC-ILC component separation run. \nIf compsep_run[\"domain\"] is \"needlet\", it will be a 2D array with alms of the tracers.\nIf compsep_run[\"domain\"] is \"pixel\", it will be a 2D array with maps of the tracers.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">config</span><span class=\"p\">:</span> <span class=\"n\">broom</span><span class=\"o\">.</span><span class=\"n\">configurations</span><span class=\"o\">.</span><span class=\"n\">Configs</span>,</span><span class=\"param\">\t<span class=\"n\">input_alms</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">compsep_run</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">field</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;B&#39;</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.clusters.get_tracers_paths_for_ratio", "modulename": "broom.clusters", "qualname": "get_tracers_paths_for_ratio", "kind": "function", "doc": "<p>Get the paths to the scalar tracers for the MC-ILC component separation run.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>config</strong> (Configs):\nConfiguration object containing the instrumental and parameters configuration. It should contain the following attributes:\n<ul>\n<li><code>nside</code>: HEALPix resolution parameter.</li>\n<li><code>lmax</code>: Maximum multipole for the tracers.</li>\n<li><code>fwhm_out</code>: Full width at half maximum of the output beam in arcminutes associated to the tracers.</li>\n</ul></li>\n<li><strong>path_tracers</strong> (str):\nPath where the tracers are stored. It should be a directory path.</li>\n<li><strong>tracers_tags</strong> (List[str]):\nList of tags for the tracers, corresponding to the frequency channels of the tracers.</li>\n<li><strong>field</strong> (str, optional):\nField of the tracers to be loaded, only \"B\" is supported. Default is \"B\".</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>tracers_paths</strong> (List[str]):\nList of paths to the scalar tracers for the MC-ILC component separation run.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">config</span><span class=\"p\">:</span> <span class=\"n\">broom</span><span class=\"o\">.</span><span class=\"n\">configurations</span><span class=\"o\">.</span><span class=\"n\">Configs</span>,</span><span class=\"param\">\t<span class=\"n\">path_tracers</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">tracers_tags</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">field</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;B&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.clusters.load_scalar_tracers_for_ratio", "modulename": "broom.clusters", "qualname": "load_scalar_tracers_for_ratio", "kind": "function", "doc": "<p>Load the scalar tracers from the specified paths.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>tracers_paths</strong> (List[str]):\nList of paths to the scalar tracers to be loaded.</li>\n<li><strong>nside</strong> (int):\nHEALPix resolution parameter for the tracers.</li>\n<li><strong>lmax</strong> (int):\nMaximum multipole for the tracers.</li>\n<li><strong>field</strong> (str, optional):\nField of the tracers to be loaded, only \"B\" is supported. Default is \"B\".</li>\n<li><strong>return_alms</strong> (bool, optional):\nWhether to return the tracers as alms or maps. If True, returns alms; if False, returns maps. Default is True.</li>\n<li><strong>kwargs</strong> (dict, optional):\nAdditional keyword arguments to be passed to healpy 'map2alm' function.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>tracers</strong> (np.ndarray):\nThe loaded scalar tracers. If <code>return_alms</code> is True, it will be a 2D array with alms of the tracers.\nIf <code>return_alms</code> is False, it will be a 2D array with maps of the tracers.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">tracers_paths</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">nside</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">lmax</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">field</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;B&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">return_alms</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.clusters.get_scalar_tracer_nl", "modulename": "broom.clusters", "qualname": "get_scalar_tracer_nl", "kind": "function", "doc": "<p>Get the scalar MC-ILC ratio tracer in the needlet domain.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>tracers</strong> (np.ndarray):\nThe scalar tracers to be filtered. It can be either a 1D array (single tracer) or a 2D array (multiple tracers).\nIf 2D, the ratio of the first tracer to the second tracer will be returned.</li>\n<li><strong>nside_</strong> (int):\nHEALPix resolution parameter for the tracers.</li>\n<li><strong>lmax_</strong> (int):\nMaximum multipole for the tracers.</li>\n<li><strong>b_ell</strong> (np.ndarray):\nNeedlet filter bandpass function to be applied to the tracers.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: The filtered scalar tracer in the needlet domain.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">tracers</span>, </span><span class=\"param\"><span class=\"n\">nside_</span>, </span><span class=\"param\"><span class=\"n\">lmax_</span>, </span><span class=\"param\"><span class=\"n\">b_ell</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "broom.clusters.get_scalar_tracer", "modulename": "broom.clusters", "qualname": "get_scalar_tracer", "kind": "function", "doc": "<p>Get the scalar MC-ILC ratio tracer in the pixel domain.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>tracers</strong> (np.ndarray):\nThe scalar tracers. It can be either a 1D array (single tracer) or a 2D array (multiple tracers).\nIf 2D, the ratio of the first tracer to the second tracer will be returned.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: The scalar tracer in the pixel domain. If <code>tracers</code> is a 1D array, it returns the tracer as is.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">tracers</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.clusters.get_tracers_compsep", "modulename": "broom.clusters", "qualname": "get_tracers_compsep", "kind": "function", "doc": "<p>Configure component separation methods for obtaining scalar tracers using GILC and needlet domains.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>channels_tracers</strong> (List[int]):\nList of channels indexes associated to the foreground tracers to be used in the component separation.</li>\n<li><strong>lmax</strong> (int):\nMaximum multipole for the component separation and analysis.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>List[Dict[str, Any]]</strong>: List of dictionaries containing the configuration for GILC run to obtain the scalar tracers.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">channels_tracers</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">lmax</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.clusters.get_mc_config", "modulename": "broom.clusters", "qualname": "get_mc_config", "kind": "function", "doc": "<p>Generate a configuration object for the MC-ILC tracers generation based on the provided configuration.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>config</strong> (Configs):\nConfiguration object containing the instrumental and parameters configuration. \n    See 'generate_and_save_real_tracers_B' for details.\ntracers_inputs_path : str\n    Path where the MC-ILC tracers inputs are stored. It should be a directory path.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Configs</strong>: A new configuration object for the MC-ILC tracers generation, with paths and parameters set according to the provided configuration.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">config</span><span class=\"p\">:</span> <span class=\"n\">broom</span><span class=\"o\">.</span><span class=\"n\">configurations</span><span class=\"o\">.</span><span class=\"n\">Configs</span>,</span><span class=\"param\">\t<span class=\"n\">tracers_inputs_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">broom</span><span class=\"o\">.</span><span class=\"n\">configurations</span><span class=\"o\">.</span><span class=\"n\">Configs</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.clusters.get_mc_data", "modulename": "broom.clusters", "qualname": "get_mc_data", "kind": "function", "doc": "<p>Simulate the input data for the MC-ILC tracers generation based on the provided configuration.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>config_mc</strong> (Configs):\nConfiguration object for the MC-ILC tracers generation. See 'get_mc_config' for details.</li>\n<li><strong>foregrounds</strong> (SimpleNamespace, optional):\nForegrounds data to be used in the simulations for tracer generation. If None, the foregrounds will be generated using the configuration parameters.</li>\n<li><strong>kwargs</strong> (dict, optional):\nAdditional keyword arguments to be passed to healpy 'map2alm' function.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>SimpleNamespace</strong>: A SimpleNamespace object containing the simulated data for the MC-ILC tracers generation. \nIt will have the following attributes:\n<ul>\n<li><code>total</code>: The total simulated data, which includes CMB, foregrounds, and noise.</li>\n<li><code>cmb</code>: The simulated CMB data.</li>\n<li><code>fgds</code>: The simulated foregrounds data.</li>\n<li><code>noise</code>: The simulated noise data.</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">config_mc</span><span class=\"p\">:</span> <span class=\"n\">broom</span><span class=\"o\">.</span><span class=\"n\">configurations</span><span class=\"o\">.</span><span class=\"n\">Configs</span>,</span><span class=\"param\">\t<span class=\"n\">foregrounds</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">systematics</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Any</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.compsep", "modulename": "broom.compsep", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "broom.compsep.get_data_and_compsep", "modulename": "broom.compsep", "qualname": "get_data_and_compsep", "kind": "function", "doc": "<p>Get data and run component separation based on the provided configuration.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>config</strong> (Configs):\nConfiguration object with settings for component separation and data handling.\nSee 'component_separation' for details on required attributes.</li>\n<li><strong>foregrounds</strong> (SimpleNamespace):\nForeground data to be used in component separation. \nIt should have the 'total' attribute, a numpy array of shape (n_channels, 3, n_alms/n_pixs)\nwhere 3 correspond to (T, Q, U) if data_type is \"maps\" or (T, E, B) if data_type is \"alms\".</li>\n<li><strong>nsim</strong> (Optional[int or str], optional):\nSimulation number to be used for saving the outputs. If None, the outputs will be saved without label on simulation number.\nDefault: None.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>SimpleNamespace or None</strong>: If <code>config.return_compsep_products</code> is True, returns outputs. Otherwise returns None.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: If the configuration is invalid or required fields are missing.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">config</span><span class=\"p\">:</span> <span class=\"n\">broom</span><span class=\"o\">.</span><span class=\"n\">configurations</span><span class=\"o\">.</span><span class=\"n\">Configs</span>, </span><span class=\"param\"><span class=\"n\">foregrounds</span>, </span><span class=\"param\"><span class=\"n\">nsim</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "broom.compsep.component_separation", "modulename": "broom.compsep", "qualname": "component_separation", "kind": "function", "doc": "<p>Run component separation methods on input data based on the specified configuration.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>config</strong> (Configs):\nConfiguration object containing the settings for component separation.\nIn particular, it should include the following attributes:\n<ul>\n<li>data_type (str): Type of data, either \"maps\" or \"alms\".</li>\n<li>field_in (str): Field associated to the provided data, e.g. TQU, QU; TEB; EB.</li>\n<li>field_out (str): Fields of the desired outputs from component separation. Default: <code>field_in</code>.</li>\n<li>lmax (int): Desired maximum multipole for the component separation and output products.</li>\n<li>nside (int): Desired HEALPix resolution of the outputs.</li>\n<li>fwhm_out (float): Full width at half maximum of the output maps in arcminutes.</li>\n<li>compsep (Dict[str, Any]): List of dictionaries containing the configuration for each component separation method to be run.</li>\n<li>mask_observations (str): Path to HEALPix mask fits file, if any. Default: None. \nIt is used to exclude unobserved regions in the alm computation and component separation.</li>\n<li>mask_covariance (str): Full path to mask used to weight adn/or exclude pixels in component separation. Default: None.</li>\n<li>leakage_correction (str): Whether to apply EB-leakage correction on input data if mask_type is \"observed_patch\". Default: None.</li>\n<li>bring_to_common_resolution (bool): Whether to bring the data to a common angular resolution (correcting for input beams). If False, the data will be used as is. Default: True.</li>\n<li>pixel_window_in (bool): Whether pixel window is included in the input data. Default: False.</li>\n<li>pixel_window_out (bool): Whether to include pixel window in the output products. Default: False.</li>\n<li>save_compsep_products (bool): Whether to save the outputs of component separation. Default: True.</li>\n<li>return_compsep_products (bool): Whether to return the outputs of component separation. Default: False.</li>\n<li>path_outputs (str): Path to the directory where the outputs will be saved if 'save_compsep_products' is True. \nIt will save them in \"working_directory/{path_outputs}/{method_specs}\", where {method_specs} is a string containing the method name, domain, and other relevant parameters.\nDefault: Working directory + \"/outputs/\".</li>\n<li>verbose (bool): Whether to print information about the component separation process. Default: False.</li>\n</ul></li>\n<li><strong>data</strong> (SimpleNamespace):\nData object containing the input data for component separation. It should have the following attributes:\n<ul>\n<li><code>total</code>: Total map or alms to be used for component separation.</li>\n<li>Other optional attributes such as <code>noise</code>, <code>cmb</code>, <code>fgds</code>, etc.</li>\n</ul></li>\n<li><strong>nsim</strong> (Optional[int or str], optional):\nSimulation number to be used for saving the outputs. If None, the outputs will be saved without label on simulation number.\nDefault: None.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>SimpleNamespace or None</strong>: If <code>config.return_compsep_products</code> is True, returns outputs. Otherwise returns None.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">config</span><span class=\"p\">:</span> <span class=\"n\">broom</span><span class=\"o\">.</span><span class=\"n\">configurations</span><span class=\"o\">.</span><span class=\"n\">Configs</span>,</span><span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">SimpleNamespace</span>,</span><span class=\"param\">\t<span class=\"n\">nsim</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">SimpleNamespace</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.compsep.estimate_residuals", "modulename": "broom.compsep", "qualname": "estimate_residuals", "kind": "function", "doc": "<p>Estimate residual foregrounds from component-separated maps.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>config</strong> (Configs):\nConfiguration object with settings for component separation. It should include:\n<ul>\n<li>mask_observations (str): Full path to HEALPix mask fits file, if any. Default: None.\nIt is used to exclude unobserved regions from loaded foreground tracers.</li>\n<li>mask_covariance (str): Full path to mask used to weight pixels in component separation.</li>\n<li>field_out (str): Fields of the desired outputs for residuals estimate. Default: <code>config.field_in</code>.</li>\n<li>compsep_residuals (list): List of dictionaries with settings for each component separation method to estimate residuals. It should contain:\n<ul>\n<li>compsep_path (str): Path to the directory containing the 'weights' folder of corresponding component separation method.\nWeights will be loaded from \"working_directory/{compsep_path}/weights. </li>\n<li>gnilc_path (str): Path to the directory containing the 'gnilc' maps to be used as multifrequency foreground tracers.\nTracers will be loaded from \"working_directory/{gnilc_path}/output_total\".</li>\n<li>field_in (str): Fields of the data to be loaded. Optional, default is <code>config.field_out</code>.</li>\n</ul></li>\n<li>lmax (int): Maximum multipole for output products.</li>\n<li>nside (int): HEALPix resolution associated to GNILC tracers and component separation weights.</li>\n<li>fwhm_out (float): Full width at half maximum associated to GNILC tracer and component separation products.</li>\n<li>pixel_window_out (bool): Whether to include pixel window in the output products. Default: False.</li>\n<li>return_compsep_products (bool): Whether to return the residuals estimate. Default: False.</li>\n<li>save_compsep_products (bool): Whether to save the residuals estimate. Default: True.</li>\n<li>verbose (bool): Whether to print information about the residuals estimate. Default: False.</li>\n</ul></li>\n<li><strong>nsim</strong> (int | str | None):\nSimulation number or identifier.</li>\n<li><strong>**kwargs</strong>: Additional keyword arguments for internal helper functions.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>SimpleNamespace or None</strong>: Residual products if <code>config.return_compsep_products</code> is True, otherwise None.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">config</span><span class=\"p\">:</span> <span class=\"n\">broom</span><span class=\"o\">.</span><span class=\"n\">configurations</span><span class=\"o\">.</span><span class=\"n\">Configs</span>,</span><span class=\"param\">\t<span class=\"n\">nsim</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">SimpleNamespace</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.configurations", "modulename": "broom.configurations", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "broom.configurations.join", "modulename": "broom.configurations", "qualname": "join", "kind": "function", "doc": "<p>Custom YAML tag to join sequences into a single string.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>loader</strong> (yaml.Loader):\nThe YAML loader instance.</li>\n<li><strong>node</strong> (yaml.Node):\nThe YAML node to process.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>str</strong>: A string formed by joining the sequence elements.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">loader</span><span class=\"p\">:</span> <span class=\"n\">yaml</span><span class=\"o\">.</span><span class=\"n\">loader</span><span class=\"o\">.</span><span class=\"n\">Loader</span>, </span><span class=\"param\"><span class=\"n\">node</span><span class=\"p\">:</span> <span class=\"n\">yaml</span><span class=\"o\">.</span><span class=\"n\">nodes</span><span class=\"o\">.</span><span class=\"n\">Node</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.configurations.parse_args", "modulename": "broom.configurations", "qualname": "parse_args", "kind": "function", "doc": "<p>Parse command-line arguments, especially the configuration file path.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>argparse.Namespace</strong>: The parsed arguments.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"n\">argparse</span><span class=\"o\">.</span><span class=\"n\">Namespace</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.configurations.get_params", "modulename": "broom.configurations", "qualname": "get_params", "kind": "function", "doc": "<p>Get parameters from a YAML configuration file.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>config_path</strong> (str, optional):\nPath to the configuration file. If not provided, uses the default path.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Configs</strong>: An instance of the Configs class containing the configuration parameters.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">config_path</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">broom</span><span class=\"o\">.</span><span class=\"n\">configurations</span><span class=\"o\">.</span><span class=\"n\">Configs</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.configurations.InstrumentConfig", "modulename": "broom.configurations", "qualname": "InstrumentConfig", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "broom.configurations.InstrumentConfig.load_from_yaml", "modulename": "broom.configurations", "qualname": "InstrumentConfig.load_from_yaml", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">yaml_data</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">experiment</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "broom.configurations.Configs", "modulename": "broom.configurations", "qualname": "Configs", "kind": "class", "doc": "<p>Class to store settings and relevant quantities for the main script.</p>\n"}, {"fullname": "broom.configurations.Configs.__init__", "modulename": "broom.configurations", "qualname": "Configs.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">config_path</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">config</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">factory</span><span class=\"o\">&gt;</span></span>)</span>"}, {"fullname": "broom.configurations.Configs.config_path", "modulename": "broom.configurations", "qualname": "Configs.config_path", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Optional[str]", "default_value": "None"}, {"fullname": "broom.configurations.Configs.config", "modulename": "broom.configurations", "qualname": "Configs.config", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Optional[Dict[str, Any]]"}, {"fullname": "broom.configurations.Configs.to_dict_for_mc", "modulename": "broom.configurations", "qualname": "Configs.to_dict_for_mc", "kind": "function", "doc": "<p>Extract relevant attributes as a dictionary.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.gilcs", "modulename": "broom.gilcs", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "broom.gilcs.gilc", "modulename": "broom.gilcs", "qualname": "gilc", "kind": "function", "doc": "<p>Performs Generalized Internal Linear Combination (GILC) component separation on scalar fields.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>config</strong> (Configs):\nConfiguration object with general settings. It includes:\n    - lmax : int, maximum multipole for the component separation.\n    - nside : int, HEALPix resolution parameter for compsep products.\n    - fwhm_out : float, full width at half maximum of the output beam in arcminutes.\n    - pixel_window_out : bool, whether to apply a pixel window to the output maps.\n    - field_out : str, desired output fields (e.g., \"T\", \"E\", \"B\", \"QU\", \"TQU\", \"QU_E\", \"QU_B\").\n    - save_compsep_products : bool, whether to save component separation products.\n    - return_compsep_products : bool, whether to return component separation products.\n    - path_outputs : str, path to save the output files.</li>\n<li><strong>input_alms</strong> (SimpleNamespace):\nInput multifrequency alms of the scalar fields. \nEach attribute should be a numpy array of shape (n_channels, (n_fields), n_alms, n_components), of the noise maps. \nwith n_fields &gt; 1 if multiple scalars are provided.\nIt should contain:\n<ul>\n<li>total : np.ndarray, alms of the total input maps.</li>\n<li>nuisance : Optional[np.ndarray], alms of the nuisance maps (if available).\nAlternatively to nuisance, it can contain:</li>\n<li>cmb : np.ndarray, alms of the CMB maps.</li>\n<li>noise : np.ndarray, alms of the noise maps.</li>\n</ul></li>\n<li><strong>compsep_run</strong> (Dict[str, Any]):\nDictionary with component separation parameters. It should include:\n<ul>\n<li>domain : str, either \"pixel\" or \"needlet\" for the component separation domain.</li>\n<li>channels_out : list, indices of the frequency channels to reconstruct with GILC. Default is all channels.</li>\n<li>depro_cmb : Optional[Union[float, list, np.ndarray]], deprojection factor for CMB (scalar or list per needlet bands). \nDefault is None.</li>\n<li>m_bias : Optional[Union[float, list, np.ndarray]], if not zero, it will include m_bias more (if m_bias &gt; 0) \nor less (if m_bias &lt; 0) modes in the reconstructed GNILC maps. Default is 0.\nIt can be a list if different values are needed for different needlet bands.</li>\n<li>cmb_nuisance : bool, whether to include CMB alms in the nuisance covariance. Default is True.</li>\n<li>needlet_config: Dictionary containing needlet settings. Needed if domain is \"needlet\". It should include:\n<ul>\n<li>\"needlet_windows\": Type of needlet windows ('cosine', 'standard', 'mexican').</li>\n<li>\"ell_peaks\": List of integers defining multipoles of peaks for needlet bands (required for 'cosine').</li>\n<li>\"width\": Width of the needlet windows (required for 'standard' and 'mexican').</li>\n<li>\"merging_needlets\": Integer or list of integers defining ranges of needlets to be merged.</li>\n</ul></li>\n<li>b_squared : bool, whether to square the needlet windows. Default is False.            </li>\n<li>adapt_nside : bool, whether to adapt the nside based on the needlet windows. Default is False.</li>\n<li>mask : Optional[np.ndarray], mask to apply to the maps (if available).</li>\n<li>cov_noise_debias : Optional[Union[float, list, np.ndarray]],\nIf not zero, it will debias the covariances by subtracting a term cov_noise_debias * noise_covariance.\nIt can be a scalar or a list per needlet bands. Default is 0.</li>\n</ul></li>\n<li><strong>**kwargs</strong> ():\nDictionary of additional keyword arguments to pass to healpy function 'map2alm'.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Optional[SimpleNamespace]</strong> ():\nOutput map object with reconstructed foreground maps if config.return_compsep_products is True.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">config</span><span class=\"p\">:</span> <span class=\"n\">broom</span><span class=\"o\">.</span><span class=\"n\">configurations</span><span class=\"o\">.</span><span class=\"n\">Configs</span>,</span><span class=\"param\">\t<span class=\"n\">input_alms</span><span class=\"p\">:</span> <span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">SimpleNamespace</span>,</span><span class=\"param\">\t<span class=\"n\">compsep_run</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">SimpleNamespace</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.gilcs.fgd_diagnostic", "modulename": "broom.gilcs", "qualname": "fgd_diagnostic", "kind": "function", "doc": "<p>Return diagnostic maps of the foreground complexity for the provided scalar fields.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>config</strong> (Configs):\nConfiguration object with general settings. It includes:\n    - lmax : int, maximum multipole for the component separation.\n    - nside : int, HEALPix resolution parameter for compsep products.\n    - fwhm_out : float, full width at half maximum of the output beam in arcminutes.\n    - field_out : str, desired fields to be considered (e.g., \"T\", \"E\", \"B\", \"TEB\").\n    - save_compsep_products : bool, whether to save diagnostic maps.\n    - return_compsep_products : bool, whether to return diagnostic maps.\n    - path_outputs : str, path to save the output files.</li>\n<li><strong>input_alms</strong> (SimpleNamespace):\nInput multifrequency alms of the scalar fields. \nEach attribute should be a numpy array of shape (n_channels, (n_fields), n_alms, n_components), \nwith n_fields &gt; 1 if multiple scalars are provided.\nIt should contain:\n<ul>\n<li>total : np.ndarray, alms of the total input maps.</li>\n<li>nuisance : Optional[np.ndarray], alms of the nuisance maps (if available).\nAlternatively to nuisance, it can contain:</li>\n<li>cmb : np.ndarray, alms of the CMB maps.</li>\n<li>noise : np.ndarray, alms of the noise maps.</li>\n</ul></li>\n<li><strong>compsep_run</strong> (Dict[str, Any]):\nDictionary with diagnostic parameters. It should include:\n    - domain : str, either \"pixel\" or \"needlet\" for the component separation domain.\n    - cmb_nuisance : bool, whether to include CMB alms in the nuisance covariance. Default is True.\n    - needlet_config: Dictionary containing needlet settings. Needed if domain is \"needlet\". It should include:\n        - \"needlet_windows\": Type of needlet windows ('cosine', 'standard', 'mexican').\n        - \"ell_peaks\": List of integers defining multipoles of peaks for needlet bands (required for 'cosine').\n        - \"width\": Width of the needlet windows (required for 'standard' and 'mexican').\n        - \"merging_needlets\": Integer or list of integers defining ranges of needlets to be merged.\n    - b_squared : bool, whether to square the needlet windows. Default is False.<br />\n    - adapt_nside : bool, whether to adapt the nside based on the needlet windows. Default is False.\n    - mask : Optional[np.ndarray], mask to apply to the maps (if available).</li>\n<li><strong>**kwargs</strong> ():\nDictionary of additional keyword arguments to pass to healpy function 'map2alm'.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Optional[SimpleNamespace]</strong>: Object containing foreground diagnostic maps.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">config</span><span class=\"p\">:</span> <span class=\"n\">broom</span><span class=\"o\">.</span><span class=\"n\">configurations</span><span class=\"o\">.</span><span class=\"n\">Configs</span>,</span><span class=\"param\">\t<span class=\"n\">input_alms</span><span class=\"p\">:</span> <span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">SimpleNamespace</span>,</span><span class=\"param\">\t<span class=\"n\">compsep_run</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">SimpleNamespace</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.gilcs.get_nuisance_idx", "modulename": "broom.gilcs", "qualname": "get_nuisance_idx", "kind": "function", "doc": "<p>Determines the index or indices of nuisance alms based on the input alms object and component separation parameters.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>input_alms</strong> (SimpleNamespace):\nInput alms object containing fields like 'total', 'nuisance', 'cmb', and 'noise'.</li>\n<li><strong>compsep_run</strong> (Dict[str, Any]):\nComponent separation parameters including 'cmb_nuisance'.</li>\n<li><strong>verbose</strong> (bool, optional):\nIf True, prints additional information about the nuisance alms being used. Default is False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Union[int, List[int]]</strong>: Index or list of indices for nuisance alms.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<p>ValueError\n    If the input_alms object does not have the required attributes for nuisance covariance.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">input_alms</span><span class=\"p\">:</span> <span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">SimpleNamespace</span>,</span><span class=\"param\">\t<span class=\"n\">compsep_run</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.gilcs.Cn_C_Cn", "modulename": "broom.gilcs", "qualname": "Cn_C_Cn", "kind": "function", "doc": "<p>Whiten the signal covariance with nuisance and perform SVD.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>C</strong> (np.ndarray):\nSignal covariance matrix. Shape should be (n_channels, n_channels) or (npix, n_channels, n_channels).</li>\n<li><strong>C_n</strong> (np.ndarray):\nNuisance covariance matrix. Shape should be (n_channels, n_channels) or (npix, n_channels, n_channels).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>tuple[np.ndarray, np.ndarray]</strong>: Tuple of eigenvalues and eigenvectors.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">C</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">C_n</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.gpilcs", "modulename": "broom.gpilcs", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "broom.gpilcs.gpilc", "modulename": "broom.gpilcs", "qualname": "gpilc", "kind": "function", "doc": "<p>Perform Generalized Polarization Internal Linear Combination (GPILC) on input spherical harmonics \nto reconstruct Galactic emission at the observed microwave frequencies.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>config</strong> (Configs):\nConfiguration object containing settings for the GPILC run. It should include:\n    - lmax : int, maximum multipole for the component separation.\n    - nside : int, HEALPix resolution parameter for compsep products.\n    - fwhm_out : float, full width at half maximum of the output beam in arcminutes.\n    - pixel_window_out : bool, whether to apply a pixel window to the output maps.\n    - field_out : str, desired output fields (e.g., \"E\", \"B\", \"QU\", \"EB\", \"QU_E\", \"QU_B\").\n    - save_compsep_products : bool, whether to save component separation products.\n    - return_compsep_products : bool, whether to return component separation products.\n    - path_outputs : str, path to save the output files.\n    - leakage_correction : str, type of leakage correction to apply (e.g., \"recycling\", \"purify\").</li>\n<li><strong>input_alms</strong> (SimpleNamespace):\nInput multifrequency alms associated to polarization. \nEach attribute should be a numpy array of shape (n_channels, 2, n_alms, n_components),\nif both E- and B-modes are provided, (n_channels, n_alms, n_components) otherwise.\nIt should contain:\n<ul>\n<li>total : np.ndarray, alms of the total input maps.</li>\n<li>nuisance : Optional[np.ndarray], alms of the nuisance maps (if available).\nAlternatively to nuisance, it can contain:</li>\n<li>cmb : np.ndarray, alms of the CMB maps.</li>\n<li>noise : np.ndarray, alms of the noise maps.</li>\n</ul></li>\n<li><strong>compsep_run</strong> (Dict[str, Any]):\nDictionary with component separation parameters. It should include:\n<ul>\n<li>domain : str, either \"pixel\" or \"needlet\" for the component separation domain.</li>\n<li>channels_out : list, indices of the frequency channels to reconstruct with GILC. Default is all channels.</li>\n<li>depro_cmb : Optional[Union[float, list, np.ndarray]], deprojection factor for CMB (scalar or per needlet band). \nDefault is None.</li>\n<li>m_bias : Optional[Union[float, list, np.ndarray]], if not zero, it will include m_bias more (if m_bias &gt; 0) \nor less (if m_bias &lt; 0) modes in the reconstructed GPILC maps. Default is 0.\nIt can be a list if different values are needed for different needlet bands.</li>\n<li>cmb_nuisance : bool, whether to include CMB alms in the nuisance covariance. Default is True.</li>\n<li>needlet_config: Dictionary containing needlet settings. Needed if domain is \"needlet\". It should include:\n<ul>\n<li>\"needlet_windows\": Type of needlet windows ('cosine', 'standard', 'mexican').</li>\n<li>\"ell_peaks\": List of integers defining multipoles of peaks for needlet bands (required for 'cosine').</li>\n<li>\"width\": Width of the needlet windows (required for 'standard' and 'mexican').</li>\n<li>\"merging_needlets\": Integer or list of integers defining ranges of needlets to be merged.</li>\n</ul></li>\n<li>mask : Optional[np.ndarray], mask to apply to the maps (if available).</li>\n<li>cov_noise_debias : Optional[Union[float, list, np.ndarray]], noise covariance debiasing factor.\nIf set to a non-zero value, it will subtract a 'noise_debias' fraction of noise covariance \nfrom the input and nuisance covariance matrices.</li>\n</ul></li>\n<li><strong>**kwargs</strong> ():\nDictionary of additional keyword arguments to pass to healpy function 'map2alm'.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Optional[SimpleNamespace]</strong>: Output object with component-separated maps, if config.return_compsep_products is True.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">config</span><span class=\"p\">:</span> <span class=\"n\">broom</span><span class=\"o\">.</span><span class=\"n\">configurations</span><span class=\"o\">.</span><span class=\"n\">Configs</span>,</span><span class=\"param\">\t<span class=\"n\">input_alms</span><span class=\"p\">:</span> <span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">SimpleNamespace</span>,</span><span class=\"param\">\t<span class=\"n\">compsep_run</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">SimpleNamespace</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.gpilcs.fgd_P_diagnostic", "modulename": "broom.gpilcs", "qualname": "fgd_P_diagnostic", "kind": "function", "doc": "<p>Perform foreground diagnostic for polarization (P) on input spherical harmonic coefficients (alms).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>config</strong> (Configs):\nConfiguration object with general settings. It includes:\n    - lmax : int, maximum multipole for the component separation.\n    - nside : int, HEALPix resolution parameter for compsep products.\n    - fwhm_out : float, full width at half maximum of the output beam in arcminutes.\n    - field_out : str, desired fields to be considered (e.g., \"T\", \"E\", \"B\", \"TEB\").\n    - save_compsep_products : bool, whether to save diagnostic maps.\n    - return_compsep_products : bool, whether to return diagnostic maps.\n    - path_outputs : str, path to save the output files.</li>\n<li><strong>input_alms</strong> (SimpleNamespace):\nInput multifrequency alms of polarization fields.\nEach attribute should be a numpy array of shape (n_channels, 2, n_alms, n_components),\nif both E- and B-modes are provided, (n_channels, n_alms, n_components) otherwise.\nIt should contain:\n<ul>\n<li>total : np.ndarray, alms of the total input maps.</li>\n<li>nuisance : Optional[np.ndarray], alms of the nuisance maps (if available).\nAlternatively to nuisance, it can contain:</li>\n<li>cmb : np.ndarray, alms of the CMB maps.</li>\n<li>noise : np.ndarray, alms of the noise maps.</li>\n</ul></li>\n<li><strong>compsep_run</strong> (Dict[str, Any]):\nDictionary with diagnostic parameters. It should include:\n    - domain : str, either \"pixel\" or \"needlet\" for the component separation domain.\n    - cmb_nuisance : bool, whether to include CMB alms in the nuisance covariance. Default is True.\n    - needlet_config: Dictionary containing needlet settings. Needed if domain is \"needlet\". It should include:\n        - \"needlet_windows\": Type of needlet windows ('cosine', 'standard', 'mexican').\n        - \"ell_peaks\": List of integers defining multipoles of peaks for needlet bands (required for 'cosine').\n        - \"width\": Width of the needlet windows (required for 'standard' and 'mexican').\n        - \"merging_needlets\": Integer or list of integers defining ranges of needlets to be merged.\n    - adapt_nside : bool, whether to adapt the nside based on the needlet windows. Default is False.\n    - mask : Optional[np.ndarray], mask to apply to the maps (if available).\n    - cov_noise_debias : Optional[Union[float, list, np.ndarray]], noise covariance debiasing factor.</li>\n<li><strong>**kwargs</strong> ():\nDictionary of additional keyword arguments to pass to healpy function 'map2alm'.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Optional[SimpleNamespace]</strong>: Object containing foreground diagnostic maps.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">config</span><span class=\"p\">:</span> <span class=\"n\">broom</span><span class=\"o\">.</span><span class=\"n\">configurations</span><span class=\"o\">.</span><span class=\"n\">Configs</span>,</span><span class=\"param\">\t<span class=\"n\">input_alms</span><span class=\"p\">:</span> <span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">SimpleNamespace</span>,</span><span class=\"param\">\t<span class=\"n\">compsep_run</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">SimpleNamespace</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.ilcs", "modulename": "broom.ilcs", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "broom.ilcs.ilc", "modulename": "broom.ilcs", "qualname": "ilc", "kind": "function", "doc": "<p>Perform Internal Linear Combination (ILC) component separation (all its variants) on CMB scalar fields.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>config</strong> (Configs):\nConfiguration object containing global settings. It includes:\n<ul>\n<li>lmax : int, maximum multipole for the component separation.</li>\n<li>nside : int, HEALPix resolution parameter for compsep products.</li>\n<li>fwhm_out : float, full width at half maximum of the output beam in arcminutes.</li>\n<li>pixel_window_out : bool, whether to apply a pixel window to the output maps.</li>\n<li>field_out : str, desired output fields (e.g., \"T\", \"E\", \"B\", \"QU\", \"TQU\", \"QU_E\", \"QU_B\").</li>\n<li>save_compsep_products : bool, whether to save component separation products.</li>\n<li>return_compsep_products : bool, whether to return component separation products.</li>\n<li>path_outputs : str, path to save the output files.</li>\n<li>units : str, units of the output maps (e.g., \"uK_CMB\"). Used to compute moments, if needed.</li>\n<li>bandpass_integrate : bool, whether inputs are bandpass-integrated. Used to compute moments, if needed.</li>\n</ul></li>\n<li><strong>input_alms</strong> (SimpleNamespace):\nSimpleNamespace object containing input spherical harmonic coefficients (alms). \nEach attribute has shape (n_channels, (n_fields), n_alms), where n_fields depend on the fields requested in config.field_out.</li>\n<li><strong>compsep_run</strong> (dict):\nDictionary specifying component separation parameters. It includes:\n<ul>\n<li>\"method\": Method to use for component separation (e.g., \"ilc\", \"cilc\", \"mc_ilc\").</li>\n<li>\"domain\": Domain of the component separation (e.g., \"pixel\", \"needlet\").</li>\n<li>\"needlet_config\": Dictionary containing needlet settings:\n<ul>\n<li>\"needlet_windows\": Type of needlet windows ('cosine', 'standard', 'mexican').</li>\n<li>\"ell_peaks\": List of integers defining multipoles of peaks for needlet bands (required for 'cosine').</li>\n<li>\"width\": Width of the needlet windows (required for 'standard' and 'mexican').</li>\n<li>\"merging_needlets\": Integer or list of integers defining ranges of needlets to be merged.</li>\n</ul></li>\n<li>\"ilc_bias\": Parameter setting the residual percentage ILC bias (default is 0. and covariance will be computed over the whole sky).</li>\n<li>\"reduce_ilc_bias\": Boolean. If True, it implements a procedure to attenuate ILC bias.</li>\n<li>\"b_squared\": Boolean indicating if the needlet windows should be squared (if domain is \"needlet\").</li>\n<li>\"adapt_nside\": Adapt HEALPix resolution of needlet maps to sampled multipole range. Deafult: False.</li>\n<li>\"save_needlets\": boolean. Whether to save adopted needlet bands in the output directory. \nIf not provided, it is set to the value of config.save_compsep_products. Default: True.</li>\n<li>\"save_weights\": boolean. Whether to save compsep weights maps in the output directory.\nIf not provided, it is set to the value of config.save_compsep_products. Default: True.</li>\n<li>\"mask\": (optional) HEALPix mask which will exclude (unobserved) regions from covariance computation. \nIt must be a 1D array with shape (12 * nside**2,). If non-binary, it will be used to weigh pixel in covariance computation.</li>\n<li>\"n_patches\": (int) Number of patches to use in MC-ILC. Default: 50.</li>\n<li>\"mc_type\": (str), needed if method is \"mcilc\" or \"mc_ilc\".\nType of MC-ILC to use. Options: \"cea_ideal\", \"rp_ideal\", \"cea_real\", \"rp_real\". Default: \"cea_real\".</li>\n<li>\"cov_noise_debias\": (float, list) Noise covariance debiasing factor. \nIf different from 0. it will debias the covariance matrix by a factor cov_noise_debias * noise_covariance.\nIt must be a list with the same length as the number of needlet scales if domain is \"needlet\", otherwise a single float.</li>\n<li>\"special_nls\": (list) List of needlet scales where moment deprojection is applied in c_ilc and clustering in mc_ilc.</li>\n<li>\"constraints\": Dictionary to be used if method is \"cilc\" or \"c_ilc\". It must contain:\n<ul>\n<li>\"moments\": list of strings with moments to be deprojected in cILC. It can be a list of lists if domain is \"needlet\".\nEach list will be associated to a needlet band in order.\nOptionally can include:</li>\n<li>\"beta_d\": (float, list): dust spectral index to compute dust moments. If list, a different beta_d is used for each needlet band. Default: 1.54.</li>\n<li>\"T_d\": (float, list): dust temperature to compute dust moments. If list, a different T_d is used for each needlet band. Default: 19.6.</li>\n<li>\"beta_s\": (float, list): synchrotron spectral index to compute synchrotron moments. If list, a different beta_s is used for each needlet band. Default: -3.</li>\n<li>\"deprojection\": (float, list): deprojection factor for each moment. If list, a different deprojection factor is used for each moment.\nIt can be a list of lists if domain is \"needlet\". Each list will be associated to a needlet band in order. Default: 0. (i.e. full deprojection) for each moment and each needlet band.</li>\n</ul></li>\n</ul></li>\n<li><strong>**kwargs</strong> (dict):\nAdditional keyword arguments forwarded to hp.map2alm.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>outputs</strong> (SimpleNamespace or None):\nOutput separated components as a SimpleNamespace object if \nconfig.return_compsep_products is True; otherwise None.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">config</span><span class=\"p\">:</span> <span class=\"n\">broom</span><span class=\"o\">.</span><span class=\"n\">configurations</span><span class=\"o\">.</span><span class=\"n\">Configs</span>,</span><span class=\"param\">\t<span class=\"n\">input_alms</span><span class=\"p\">:</span> <span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">SimpleNamespace</span>,</span><span class=\"param\">\t<span class=\"n\">compsep_run</span><span class=\"p\">:</span> <span class=\"n\">Dict</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">SimpleNamespace</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.ilcs.get_ilc_weights", "modulename": "broom.ilcs", "qualname": "get_ilc_weights", "kind": "function", "doc": "<p>Compute Internal Linear Combination (ILC) weights for a given spectral component (typically CMB).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>A_cmb</strong> (np.ndarray):\nSpectral response vector of the target component (e.g., CMB), shape (n_channels,).</li>\n<li><strong>inv_cov</strong> (np.ndarray):\nInverse of the covariance matrix. Can be 2D or 3D depending on bias settings.</li>\n<li><strong>input_shapes</strong> (tuple):\nShape of the input map, used to reshape or broadcast weights.</li>\n<li><strong>compsep_run</strong> (dict):\nDictionary specifying component separation settings, including:\n<ul>\n<li>'A': Optional constraint matrix for deprojection of additional components. Shape (n_components, n_channels).</li>\n<li>'e': Deprojection vector. Shape (n_components,).</li>\n<li>'ilc_bias': Flag indicating if covariance is pixel-independent (0.0) or not.</li>\n<li>'mask': Optional binary mask used for excluding unobserved regions.</li>\n</ul></li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: ILC weights with shape (n_channels, n_pixels) if ilc_bias is not 0.0,\notherwise (n_channels,).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">A_cmb</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">inv_cov</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">input_shapes</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">compsep_run</span><span class=\"p\">:</span> <span class=\"n\">Dict</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.ilcs.get_mcilc_weights", "modulename": "broom.ilcs", "qualname": "get_mcilc_weights", "kind": "function", "doc": "<p>Compute weights for the MC-ILC method over spatial patches.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>inputs</strong> (np.ndarray):\nInput sky maps, shape (n_channels, n_pixels).</li>\n<li><strong>patches</strong> (np.ndarray):\nInteger labels assigning each pixel to a spatial patch.</li>\n<li><strong>A_cmb</strong> (np.ndarray):\nSpectral response of the CMB component, shape (n_channels,).</li>\n<li><strong>compsep_run</strong> (dict):\nDictionary with MCILC options, including optional constraints and bias reduction. See 'ilc' for details.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: MCILC weights for each pixel, shape (n_channels, n_pixels).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">inputs</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">patches</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">A_cmb</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">compsep_run</span><span class=\"p\">:</span> <span class=\"n\">Dict</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.ilcs.get_ilc_cov", "modulename": "broom.ilcs", "qualname": "get_ilc_cov", "kind": "function", "doc": "<p>Compute the input covariance matrix for ILC.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>input_maps</strong> (np.ndarray):\nInput sky maps, shape (n_channels, n_pixels).</li>\n<li><strong>lmax</strong> (int):\nMaximum multipole.</li>\n<li><strong>compsep_run</strong> (dict):\nDictionary controlling ILC behavior (bias flags, mask, etc.). See 'ilc' for details.</li>\n<li><strong>b_ell</strong> (np.ndarray):\nNeedlet harmonic window function, if applicable.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: Covariance matrix, either global (2D) or pixel-dependent (3D).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">input_maps</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">lmax</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">compsep_run</span><span class=\"p\">:</span> <span class=\"n\">Dict</span>,</span><span class=\"param\">\t<span class=\"n\">b_ell</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.ilcs.get_mcilc_cov", "modulename": "broom.ilcs", "qualname": "get_mcilc_cov", "kind": "function", "doc": "<p>Compute pixel-wise covariance matrices for MC-ILC based on patching and optional donut-masking.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>inputs</strong> (np.ndarray):\nInput sky maps, shape (n_channels, n_pixels).</li>\n<li><strong>patches</strong> (np.ndarray):\nPixel-wise patch labels.</li>\n<li><strong>mask_mcilc</strong> (np.ndarray):\nBinary mask to include/exclude pixels.</li>\n<li><strong>reduce_bias</strong> (bool, default=True):\nWhether to apply donut masking to reduce MCILC bias.</li>\n<li><strong>mcilc_rings</strong> (int, default=4):\nNumber of HEALPix neighbor rings to exclude when reducing bias.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: Covariance matrix per pixel, shape (n_channels, n_channels, n_valid_pixels).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">inputs</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">patches</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">mask_mcilc</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">reduce_bias</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">mcilc_rings</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">4</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.ilcs.get_inv_cov", "modulename": "broom.ilcs", "qualname": "get_inv_cov", "kind": "function", "doc": "<p>Invert covariance matrices for ILC or MC-ILC processing.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>cov</strong> (np.ndarray):\nCovariance matrix of shape (n_channels, n_channels) or (n_channels, n_channels, n_pixels).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: Inverted covariance matrix with same shape.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">cov</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.inputs", "modulename": "broom.inputs", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "broom.leakage", "modulename": "broom.leakage", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "broom.leakage.purify_master", "modulename": "broom.leakage", "qualname": "purify_master", "kind": "function", "doc": "<p>Purify the E and B modes of the input QU maps using purification in NaMaster package.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>QU_maps</strong> (array of Healpix maps):\nThe input maps containing Q and U components.</li>\n<li><strong>mask</strong> (array):\nThe mask to apply to the maps.</li>\n<li><strong>lmax</strong> (int):\nThe maximum multipole to consider for purification.</li>\n<li><strong>return_E</strong> (bool, optional):\nIf True, return the E-mode alms. Default is True.</li>\n<li><strong>return_B</strong> (bool, optional):\nIf True, return the B-mode alms. Default is True.</li>\n<li><strong>purify_E</strong> (bool, optional):\nIf True, perform purification of E modes. Default is False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>alms_p</strong> (array):\nThe purified alms for E and/or B modes based on the input flags.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">QU_maps</span>, </span><span class=\"param\"><span class=\"n\">mask</span>, </span><span class=\"param\"><span class=\"n\">lmax</span>, </span><span class=\"param\"><span class=\"n\">return_E</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">return_B</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">purify_E</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "broom.leakage.purify_recycling", "modulename": "broom.leakage", "qualname": "purify_recycling", "kind": "function", "doc": "<p>Purify the E and B modes of the input QU maps using recycling technique.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>QU_maps</strong> (array of Healpix maps):\nThe input maps containing Q and U components.</li>\n<li><strong>QU_full_maps</strong> (array of Healpix maps):\nThe Q and U maps containing the full signal over which the purification is actually performed.</li>\n<li><strong>mask</strong> (array):\nThe mask to apply to the maps.</li>\n<li><strong>lmax</strong> (int):\nThe maximum multipole to consider for purification.</li>\n<li><strong>return_E</strong> (bool, optional):\nIf True, return the E-mode alms. Default is True.</li>\n<li><strong>return_B</strong> (bool, optional):\nIf True, return the B-mode alms. Default is True.</li>\n<li><strong>purify_E</strong> (bool, optional):\nIf True, perform purification of E modes. Default is False.</li>\n<li><strong>iterations</strong> (int, optional):\nNumber of iterations for recycling purification. Default is 0.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>alms_p</strong> (array):\nThe purified alms for E and/or B modes based on the input flags.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">QU_maps</span>,</span><span class=\"param\">\t<span class=\"n\">QU_full_maps</span>,</span><span class=\"param\">\t<span class=\"n\">mask</span>,</span><span class=\"param\">\t<span class=\"n\">lmax</span>,</span><span class=\"param\">\t<span class=\"n\">return_E</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">return_B</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">purify_E</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">iterations</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "broom.masking", "modulename": "broom.masking", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "broom.masking.is_binary_mask", "modulename": "broom.masking", "qualname": "is_binary_mask", "kind": "function", "doc": "<p>Check if a mask is binary (contains only 0.0 and 1.0).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>mask</strong> (np.ndarray):\nThe input mask.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>bool</strong>: True if binary, False otherwise.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">mask</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.masking.get_threshold_mask", "modulename": "broom.masking", "qualname": "get_threshold_mask", "kind": "function", "doc": "<p>Apply a threshold-based masking strategy to reduce the sky fraction.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>map_</strong> (np.ndarray):\nInput residual tracer map(s), shape (n_fields, npix) or (npix,) to be thresholded.</li>\n<li><strong>mask_init</strong> (np.ndarray):\nInitial binary mask.</li>\n<li><strong>field_cls_in</strong> (str):\nFields associated to map_ (e.g., \"TQU\", \"QU\").</li>\n<li><strong>fsky</strong> (float):\nDesired final sky fraction.</li>\n<li><strong>lmax</strong> (int):\nMaximum multipole to consider.</li>\n<li><strong>smooth_tracer</strong> (float):\nFWHM in degrees for smoothing the tracer map.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: Final binary mask with the desired sky fraction.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">map_</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">mask_init</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">field_cls_in</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">fsky</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">lmax</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">smooth_tracer</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">3.0</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.masking.threshold_scalar_tracer", "modulename": "broom.masking", "qualname": "threshold_scalar_tracer", "kind": "function", "doc": "<p>Generate a threshold mask from a scalar tracer map.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>map_</strong> (np.ndarray):\nScalar tracer map.</li>\n<li><strong>mask_in</strong> (np.ndarray):\nInitial mask.</li>\n<li><strong>npix_mask</strong> (int):\nNumber of additional pixels to mask.</li>\n<li><strong>lmax</strong> (int):\nMaximum multipole to be considerd for smoothing the tracer map.</li>\n<li><strong>smooth_tracer</strong> (float):\nSmoothing FWHM in degrees.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: Threshold mask.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">map_</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">mask_in</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">npix_mask</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">lmax</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">smooth_tracer</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">3.0</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.masking.threshold_P_tracer", "modulename": "broom.masking", "qualname": "threshold_P_tracer", "kind": "function", "doc": "<p>Generate a threshold mask from polarization tracers maps (Q, U).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>map_</strong> (np.ndarray):\nPolarization tracers maps [Q, U]. Shape: (2, npix).</li>\n<li><strong>mask_in</strong> (np.ndarray):\nInitial mask.</li>\n<li><strong>npix_mask</strong> (int):\nNumber of pixels to mask.</li>\n<li><strong>lmax</strong> (int):\nMaximum multipole to be considerd for smoothing the tracers maps.</li>\n<li><strong>smooth_tracer</strong> (float):\nSmoothing FWHM in degrees.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong> ():\nThresholded polarization mask.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">map_</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">mask_in</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">npix_mask</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">lmax</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">smooth_tracer</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">3.0</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.masking.get_planck_mask", "modulename": "broom.masking", "qualname": "get_planck_mask", "kind": "function", "doc": "<p>Downloads and processes a Planck Galactic mask.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<pre><code>apo: int \n    Apodization level (default 5).\nnside: int \n    HEALPix resolution.\nfield: int \n    Field to read.\ninfo: bool \n    Whether to return header info.\n</code></pre>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray or tuple</strong> ():\nMask data or (mask, header).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">apo</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">nside</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">2048</span>,</span><span class=\"param\">\t<span class=\"n\">field</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">3</span>,</span><span class=\"param\">\t<span class=\"n\">info</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"nb\">tuple</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.masking.get_masks_for_compsep", "modulename": "broom.masking", "qualname": "get_masks_for_compsep", "kind": "function", "doc": "<p>Get observation and covariance masks for component separation.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>mask_obs</strong> (Union[str, np.ndarray, None]):\nPath to the observation mask fits file or a numpy array. If None, no observation mask is applied.</li>\n<li><strong>mask_cov</strong> (Union[str, np.ndarray, None]):\nPath to the covariance mask fits file or a numpy array. If None, the observation mask is used as the covariance mask.</li>\n<li><strong>nside</strong> (int):\nHEALPix resolution for the masks in output.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Tuple[Union[np.ndarray, None], Union[np.ndarray, None]]:</strong>: Tuple containing the observation mask and covariance mask as numpy arrays. If no mask is provided, returns None.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">mask_obs</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">mask_cov</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">nside</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">],</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.needlets", "modulename": "broom.needlets", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "broom.needlets.get_cosine_windows", "modulename": "broom.needlets", "qualname": "get_cosine_windows", "kind": "function", "doc": "<p>Generate cosine-based needlet windows.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>lmax</strong> (int):\nMaximum multipole.</li>\n<li><strong>needlet_config</strong> (dict):\nConfiguration with key \"ell_peaks\" (list of peak positions).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: Cosine window array (n_bands, lmax+1).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">lmax</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">needlet_config</span><span class=\"p\">:</span> <span class=\"n\">Dict</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.needlets.get_standard_windows", "modulename": "broom.needlets", "qualname": "get_standard_windows", "kind": "function", "doc": "<p>Generate standard needlet windows.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>lmax</strong> (int):\nMaximum multipole.</li>\n<li><strong>needlet_config</strong> (dict):\nMust contain 'width' and optionally 'merging_needlets'.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: Standard needlet windows.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">lmax</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">needlet_config</span><span class=\"p\">:</span> <span class=\"n\">Dict</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.needlets.get_mexican_windows", "modulename": "broom.needlets", "qualname": "get_mexican_windows", "kind": "function", "doc": "<p>Generate Mexican needlet windows.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>lmax</strong> (int):\nMaximum multipole.</li>\n<li><strong>needlet_config</strong> (dict):\nMust contain 'width' and optionally 'merging_needlets'.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: Mexican needlet windows.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">lmax</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">needlet_config</span><span class=\"p\">:</span> <span class=\"n\">Dict</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.pilcs", "modulename": "broom.pilcs", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "broom.pilcs.pilc", "modulename": "broom.pilcs", "qualname": "pilc", "kind": "function", "doc": "<p>Perform Polarization Internal Linear Combination (PILC) on input alm coefficients.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>config</strong> (Configs):\nConfiguration object containing global settings. It includes:\n<ul>\n<li>lmax : int, maximum multipole for the component separation.</li>\n<li>nside : int, HEALPix resolution parameter for compsep products.</li>\n<li>fwhm_out : float, full width at half maximum of the output beam in arcminutes.</li>\n<li>pixel_window_out : bool, whether to apply a pixel window to the output maps.</li>\n<li>field_out : str, desired output fields (e.g., \"E\", \"B\", \"QU\", \"QU_E\", \"QU_B\").</li>\n<li>save_compsep_products : bool, whether to save component separation products.</li>\n<li>return_compsep_products : bool, whether to return component separation products.</li>\n<li>path_outputs : str, path to save the output files.</li>\n<li>units : str, units of the output maps (e.g., \"uK_CMB\"). Used to compute moments, if needed.</li>\n<li>bandpass_integrate : bool, whether inputs are bandpass-integrated. Used to compute moments, if needed.</li>\n</ul></li>\n<li><strong>input_alms</strong> (SimpleNamespace):\nSimpleNamespace object containing input spherical harmonic coefficients (alms). \nEach attribute has shape (n_channels, (n_fields), n_alms), where n_fields depend on the fields requested in config.field_out. \nn_fields can be None if only E and B are requested, or 2 if both are requested to be included in P component separation.</li>\n<li><strong>compsep_run</strong> (dict):\nDictionary specifying component separation parameters. It includes:\n<ul>\n<li>\"method\": Method to use for component separation (e.g., \"pilc\", \"cpilc\").</li>\n<li>\"domain\": Domain of the component separation (e.g., \"pixel\", \"needlet\").</li>\n<li>\"needlet_config\": Configuration for needlet parameters (if applicable).</li>\n<li>\"ilc_bias\": Parameter setting the residual percentage ILC bias (default is 0. and covariance will be computed over the whole sky).</li>\n<li>\"reduce_ilc_bias\": Boolean. If True, it implements a procedure to attenuate ILC bias.</li>\n<li>\"save_needlets\": boolean. Whether to save adopted needlet bands in the output directory. \nIf not provided, it is set to the value of config.save_compsep_products. Default: True.</li>\n<li>\"save_weights\": boolean. Whether to save compsep weights maps in the output directory.\nIf not provided, it is set to the value of config.save_compsep_products. Default: True.</li>\n<li>\"mask\": (optional) HEALPix mask which will exclude (unobserved) regions from covariance computation. \nIt must be a 1D array with shape (12 * nside**2,). If non-binary, it will be used to weigh pixel in covariance computation.</li>\n<li>\"cov_noise_debias\": (float, list) Noise covariance debiasing factor. \nIf different from 0. it will debias the covariance matrix by a factor cov_noise_debias * noise_covariance.\nIt must be a list with the same length as the number of needlet scales if domain is \"needlet\", otherwise a single float.</li>\n<li>\"special_nls\": (list) List of needlet scales where moment deprojection is applied in c_pilc.</li>\n<li>\"constraints\": Dictionary to be used if method is \"cpilc\" or \"c_pilc\". It must contain:\n<ul>\n<li>\"moments\": list of strings with moments to be deprojected in cPILC. It can be a list of lists if domain is \"needlet\".\nEach list will be associated to a needlet band in order.\nOptionally can include:</li>\n<li>\"beta_d\": (float, list): dust spectral index to compute dust moments. If list, a different beta_d is used for each needlet band. Default: 1.54.</li>\n<li>\"T_d\": (float, list): dust temperature to compute dust moments. If list, a different T_d is used for each needlet band. Default: 19.6.</li>\n<li>\"beta_s\": (float, list): synchrotron spectral index to compute synchrotron moments. If list, a different beta_s is used for each needlet band. Default: -3.</li>\n<li>\"deprojection\": (float, list): deprojection factor for each moment. If list, a different deprojection factor is used for each moment.\nIt can be a list of lists if domain is \"needlet\". Each list will be associated to a needlet band in order. Default: 0. (i.e. full deprojection) for each moment and each needlet band.</li>\n</ul></li>\n</ul></li>\n<li><strong>**kwargs</strong> (dict):\nAdditional keyword arguments forwarded to hp.map2alm.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>SimpleNamespace or None</strong>: Output maps if config.return_compsep_products is True, otherwise None.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">config</span><span class=\"p\">:</span> <span class=\"n\">broom</span><span class=\"o\">.</span><span class=\"n\">configurations</span><span class=\"o\">.</span><span class=\"n\">Configs</span>,</span><span class=\"param\">\t<span class=\"n\">input_alms</span><span class=\"p\">:</span> <span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">SimpleNamespace</span>,</span><span class=\"param\">\t<span class=\"n\">compsep_run</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">SimpleNamespace</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.pilcs.get_pilc_weights", "modulename": "broom.pilcs", "qualname": "get_pilc_weights", "kind": "function", "doc": "<p>Compute weights for the Polarization Internal Linear Combination (PILC) method,\nwith or without constraints to deproject additional components.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<pre><code>A_cmb: np.ndarray\n    Spectral energy distribution (SED) of the CMB. Shape: (n_channels,)\ninv_cov: np.ndarray\n    Inverse covariance matrix of input polarization maps:\n    - If ilc_bias=0: shape (n_channels, n_channels)\n    - If ilc_bias!=0: shape (n_channels, n_channels, n_pixels)\ninput_shapes: Tuple[int, ...]\n    Shape of the input map (n_channels, 2, n_pixels, n_comps) or equivalent, used to determine spatial size and channels.\ncompsep_run: Dict\n    Dictionary with component separation settings. See 'pilc' function for details.\n</code></pre>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>w_ilc</strong> (np.ndarray):\nILC weights, shaped:\n    - (n_channels,) if ilc_bias = 0\n    - (n_channels, n_pixels) if ilc_bias != 0</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">A_cmb</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">inv_cov</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">input_shapes</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">compsep_run</span><span class=\"p\">:</span> <span class=\"n\">Dict</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.pilcs.get_pilc_cov", "modulename": "broom.pilcs", "qualname": "get_pilc_cov", "kind": "function", "doc": "<p>Compute full PILC covariance matrix.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<pre><code>input_maps: np.ndarray\n    input Q/U maps. Shape (n_channels, 2, n_pixels)\nlmax: int\n    Maximum multipole for the analysis.\ncompsep_run: Dict\n    Dictionary with component separation settings. See 'pilc' function for details.\nb_ell: np.ndarray\n    Needlet window function for the current scale. It should be a 1D array of shape (lmax+1,).\n</code></pre>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>cov</strong> (np.ndarray):\nFull 2x2 polarization covariance matrix of shape (2<em>n_channels, 2</em>n_channels, [n_pixels]).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">input_maps</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">lmax</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">compsep_run</span><span class=\"p\">:</span> <span class=\"n\">Dict</span>,</span><span class=\"param\">\t<span class=\"n\">b_ell</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.pilcs.get_prilc_cov", "modulename": "broom.pilcs", "qualname": "get_prilc_cov", "kind": "function", "doc": "<p>Compute the reduced ILC covariance matrix for polarization maps.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<pre><code>input_maps: np.ndarray\n    input Q/U maps. Shape (n_channels, 2, n_pixels)\nlmax: int\n    Maximum multipole for the analysis.\ncompsep_run: Dict\n    Dictionary with component separation settings. See 'pilc' function for details.\nb_ell: np.ndarray\n    Needlet window function for the current scale. It should be a 1D array of shape (lmax+1,).\n</code></pre>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>cov</strong> (np.ndarray):\nCovariance matrix of shape (n_channels, n_channels, [n_pixels]).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">input_maps</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">lmax</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">compsep_run</span><span class=\"p\">:</span> <span class=\"n\">Dict</span>,</span><span class=\"param\">\t<span class=\"n\">b_ell</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.routines", "modulename": "broom.routines", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "broom.routines.merge_dicts", "modulename": "broom.routines", "qualname": "merge_dicts", "kind": "function", "doc": "<p>Merge a list of single-key dictionaries into one dictionary, or return the dictionary itself.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<pre><code>d: dictionary or a list of dictionaries\n    If a list, each dict is expected to have exactly one key.\n</code></pre>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Dict[Any, Any]</strong>: A single merged dictionary.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong> ():\nIf input is not a dict or list of single-key dicts.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">d</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]],</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.routines.obj_to_array", "modulename": "broom.routines", "qualname": "obj_to_array", "kind": "function", "doc": "<p>Convert a SimpleNamespace object with specified attributes into a numpy array.</p>\n\n<p>Attributes are stacked along the last axis.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>obj</strong>: SimpleNamespace with attributes like \"total\", \"fgds\", etc.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: A numpy array representation of the object's attributes.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong> (If input is not a SimpleNamespace.):</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">SimpleNamespace</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.routines.obj_out_to_array", "modulename": "broom.routines", "qualname": "obj_out_to_array", "kind": "function", "doc": "<p>Convert a SimpleNamespace object with output-related attributes to a numpy array.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>obj</strong>: SimpleNamespace with attributes like \"output_total\", \"noise_residuals\", etc.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: A numpy array stacking the specified attributes.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong> (If input is not a SimpleNamespace.):</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">SimpleNamespace</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.routines.array_to_obj", "modulename": "broom.routines", "qualname": "array_to_obj", "kind": "function", "doc": "<p>Convert a numpy array back to a SimpleNamespace object with specific attributes,\nbased on attributes present in the reference object.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>array</strong> (np.ndarray):\nNumpy array where the last dimension corresponds to attributes.\nobj: SimpleNamespace object to reference which attributes to set.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>SimpleNamespace</strong>: SimpleNamespace with attributes set from array slices.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">array</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">SimpleNamespace</span></span><span class=\"return-annotation\">) -> <span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">SimpleNamespace</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.saving", "modulename": "broom.saving", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "broom.saving.get_gnilc_maps", "modulename": "broom.saving", "qualname": "get_gnilc_maps", "kind": "function", "doc": "<p>Load GNILC component separation results (total signal, noise residuals, and foreground residuals) of all frequency channels\nprovided in the instrument object and for a given simulation run and field. </p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>config</strong> (Configs):\nConfiguration object containing instrument and output specifications.</li>\n<li><strong>path_gnilc</strong> (str):\nRoot path to the GNILC output directory. The full path will be given by '{config.path_outputs}/{path_gnilc}'.</li>\n<li><strong>field_in</strong> (Optional[str], default=None):\nType of field to load (\"T\", \"QU\", \"EB\", \"TQU\", \"TEB\", etc.). If None, default is config.field_out.</li>\n<li><strong>nsim</strong> (Optional[Union[str, int]], default=None):\nSimulation identifier, if any (used to select specific simulation output files).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>gnilc_maps</strong> (SimpleNamespace):\nA container with the following attributes:\n<ul>\n<li>total: np.ndarray of GNILC total signal maps.</li>\n<li>noise: np.ndarray of noise residual maps (if available).</li>\n<li>fgds: np.ndarray of foreground residual maps (if available).</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">config</span><span class=\"p\">:</span> <span class=\"n\">broom</span><span class=\"o\">.</span><span class=\"n\">configurations</span><span class=\"o\">.</span><span class=\"n\">Configs</span>,</span><span class=\"param\">\t<span class=\"n\">path_gnilc</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">field_in</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">nsim</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">SimpleNamespace</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.saving.save_ilc_weights", "modulename": "broom.saving", "qualname": "save_ilc_weights", "kind": "function", "doc": "<p>Save ILC component separation weights to disk with appropriate metadata in filename.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>config</strong> (Configs):\nConfiguration object.</li>\n<li><strong>w</strong> (np.ndarray):\ncomponent separation weights to be saved.</li>\n<li><strong>compsep_run</strong> (dict):\nDictionary with component separation parameters.</li>\n<li><strong>nside_</strong> (int):\nHEALPix NSIDE resolution of the output.</li>\n<li><strong>nl_scale</strong> (int, optional):\nNeedlet scale index for the corresponding ILC run.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong>: It saves the weights to disk in the specified directory structure \nbased on the component separation method and configuration.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">config</span><span class=\"p\">:</span> <span class=\"n\">broom</span><span class=\"o\">.</span><span class=\"n\">configurations</span><span class=\"o\">.</span><span class=\"n\">Configs</span>,</span><span class=\"param\">\t<span class=\"n\">w</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">compsep_run</span><span class=\"p\">:</span> <span class=\"n\">Dict</span>,</span><span class=\"param\">\t<span class=\"n\">nside_</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">nl_scale</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.saving.save_patches", "modulename": "broom.saving", "qualname": "save_patches", "kind": "function", "doc": "<p>Save MC-ILC patches to disk with appropriate metadata in filename.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>config</strong> (Configs):\nConfiguration object.</li>\n<li><strong>patches</strong> (np.ndarray):\nMC-ILC patches to be saved.</li>\n<li><strong>compsep_run</strong> (dict):\nDictionary with component separation parameters.</li>\n<li><strong>nl_scale</strong> (int, optional):\nNeedlet scale index for the corresponding ILC run.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong>: It saves the MC-ILC patches to disk in the specified directory structure</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">config</span><span class=\"p\">:</span> <span class=\"n\">broom</span><span class=\"o\">.</span><span class=\"n\">configurations</span><span class=\"o\">.</span><span class=\"n\">Configs</span>,</span><span class=\"param\">\t<span class=\"n\">patches</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">compsep_run</span><span class=\"p\">:</span> <span class=\"n\">Dict</span>,</span><span class=\"param\">\t<span class=\"n\">nl_scale</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.saving.save_spectra", "modulename": "broom.saving", "qualname": "save_spectra", "kind": "function", "doc": "<p>Save the computed spectra to files based on the configuration and compute_cls dictionary.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>config</strong> (Configs):\nConfiguration object containing parameters for spectra computation. See <code>_compute_spectra</code> for details.</li>\n<li><strong>cls_out</strong> (SimpleNamespace):\nObject containing computed spectra with attributes for each component.</li>\n<li><strong>compute_cls</strong> (dict):\nDictionary containing parameters for spectra computation. See <code>_compute_spectra</code> for details.</li>\n<li><strong>nsim</strong> (str, optional):\nSimulation number to save spectra.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong>: It saves the computed spectra to disk in the specified directory structure.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">config</span><span class=\"p\">:</span> <span class=\"n\">broom</span><span class=\"o\">.</span><span class=\"n\">configurations</span><span class=\"o\">.</span><span class=\"n\">Configs</span>,</span><span class=\"param\">\t<span class=\"n\">cls_out</span><span class=\"p\">:</span> <span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">SimpleNamespace</span>,</span><span class=\"param\">\t<span class=\"n\">compute_cls</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">nsim</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.saving.get_path_spectra", "modulename": "broom.saving", "qualname": "get_path_spectra", "kind": "function", "doc": "<p>Get the path where spectra will be saved based on the compute_cls dictionary.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>config</strong> (Configs):\nConfiguration object containing paths and parameters for spectra computation.</li>\n<li><strong>compute_cls</strong> (dict):\nDictionary containing parameters for spectra computation, including mask type and fsky.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>str</strong>: Full path to the directory where spectra will be saved.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">config</span><span class=\"p\">:</span> <span class=\"n\">broom</span><span class=\"o\">.</span><span class=\"n\">configurations</span><span class=\"o\">.</span><span class=\"n\">Configs</span>, </span><span class=\"param\"><span class=\"n\">compute_cls</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.seds", "modulename": "broom.seds", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "broom.simulations", "modulename": "broom.simulations", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "broom.spectra", "modulename": "broom.spectra", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "broom.spectra.get_bls", "modulename": "broom.spectra", "qualname": "get_bls", "kind": "function", "doc": "<p>Get the beam transfer functions for the required fields and lmax.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>nside</strong> (int):\nHEALPix nside parameter.</li>\n<li><strong>fwhm</strong> (float):\nFull width at half maximum of the beam in arcminutes.</li>\n<li><strong>lmax</strong> (int):\nMaximum multipole to consider.</li>\n<li><strong>field_cls_out</strong> (str):\nFields for which to compute the beam transfer functions.</li>\n<li><strong>pixel_window_out</strong> (bool, optional):\nWhether to consider the pixel window function in the beam transfer functions. Default is True.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>bls_beam</strong> (np.ndarray):\nBeam transfer functions for the specified fields and lmax.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">nside</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">fwhm</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">lmax</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">field_cls_out</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">pixel_window_out</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "broom.templates", "modulename": "broom.templates", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "broom.templates.get_residuals_template", "modulename": "broom.templates", "qualname": "get_residuals_template", "kind": "function", "doc": "<p>Estimates the foreground residuals template from input foregrounds multifrequency templates using \ncomponent separation weights as defined in compsep_run dictionary.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>config</strong> (Configs):\nConfiguration object containing the global settings. It should include the following attributes:\n<ul>\n<li>nside: The HEALPix resolution parameter.</li>\n<li>lmax: The maximum multipole for the analysis.</li>\n<li>fwhm_out: The full width at half maximum for the foreground templates and at which weights\nwere computed.</li>\n<li>pixel_window_out: Boolean indicating whether to apply pixel windowing to the output maps.</li>\n<li>save_compsep_products: Boolean indicating whether to save the residuals templates.</li>\n<li>return_compsep_products: Boolean indicating whether to return the residuals templates.</li>\n<li>mask_type: Type of mask to apply, e.g., \"observed_patch\".</li>\n<li>leakage_correction: Method for leakage correction, e.g., \"purify\", or \"recycling\". Used \nonly for PILC residuals estimation.</li>\n<li>field_out: The field to be outputted, e.g., \"E\", \"B\", \"EB\", \"QU\", \"QU_E\", or \"QU_B\".</li>\n</ul></li>\n<li><strong>input_alms</strong> (np.ndarray):\nInput foregrounds multifrequency templates in alm format. The shape should be (n_freqs, n_fields, n_alms, n_comps) where:\n<ul>\n<li>n_freqs: Number of frequency channels.</li>\n<li>n_fields: Number of fields, not None only if multiple fields are being processed simultaneously.</li>\n<li>n_alms: Number of spherical harmonic coefficients.</li>\n<li>n_comps: Number of components referring to foreground templates (e.g. total, noise residuals, etc.).</li>\n</ul></li>\n<li><strong>compsep_run</strong> (dict):\nDictionary containing the residuals estimates run parameters. It should include:\n<ul>\n<li>compsep_path: Path to the component separation weights.</li>\n<li>field_in_cs: The field associated to input templates and component separation weights, e.g., \"T\", \"E\", \"B\", \"QU_E\", \"QU_B\".</li>\n<li>nsim: Simulation number if applicable, otherwise None.</li>\n<li>adapt_nside: Boolean indicating whether to adapt nside based on the needlet bands.</li>\n<li>mask: Optional mask to apply to the output maps.</li>\n</ul></li>\n<li><strong>kwargs</strong> (dict):\nAdditional keywords for healpy map2alm function.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>SimpleNamespace or None</strong>: Estimate of foreground residuals for component separation of scalar fields or for PILC.\nIt may have the following attributes:\n<ul>\n<li>fgres_templates: Total foreground residuals.</li>\n<li>fgres_templates_noise: Noise contamination in the foreground residuals template.</li>\n<li>fgres_templates_ideal: Pure foreground component in the template.\nEach attribute has shape (n_fields, n_pixels) with n_fields depending on config.field_out.</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">config</span><span class=\"p\">:</span> <span class=\"n\">broom</span><span class=\"o\">.</span><span class=\"n\">configurations</span><span class=\"o\">.</span><span class=\"n\">Configs</span>,</span><span class=\"param\">\t<span class=\"n\">input_alms</span><span class=\"p\">:</span> <span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">SimpleNamespace</span>,</span><span class=\"param\">\t<span class=\"n\">compsep_run</span><span class=\"p\">:</span> <span class=\"nb\">dict</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">SimpleNamespace</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();